# Beispiel-Datei mit Tabellen, Beispiel-Abfragen und erwarteten Ergebnissen
# Ziel: leicht lesbar, direkt nutzbar für Test-Suiten.
# Struktur:
# tables: { name: { cols: [..], rows: [ [..], ... ] } }
# queries: - id, description, sql, expected: { cols: [...], rows: [ {col: val}, ... ] }

tables:
  test_table:
    cols: [id, name, value]
    rows:
      - [1, "alice", 100.0]
      - [2, "bob", 200.0]
      - [3, "charlie", 150.0]
      - [4, "alice", 300.0]
      - [5, "alice", 250.0]

  users:
    cols: [id, name]
    rows:
      - [1, "alice"]
      - [2, "bob"]
      - [3, "carol"]

  orders:
    cols: [id, user_id, amount, status]
    rows:
      - [1, 1, 100.0, "PAID"]
      - [2, 1, 200.0, "PENDING"]
      - [3, 2, 150.0, "PAID"]
      - [4, 1, 300.0, "PAID"]

queries:
  - id: simple_select
    description: "Einfache SELECT-Abfrage, alle Spalten aus test_table"
    sql: "SELECT id, name, value FROM test_table ORDER BY id"
    expected:
      cols: [id, name, value]
      rows:
        - {id: 1, name: "alice", value: 100.0}
        - {id: 2, name: "bob", value: 200.0}
        - {id: 3, name: "charlie", value: 150.0}
        - {id: 4, name: "alice", value: 300.0}
        - {id: 5, name: "alice", value: 250.0}

  - id: group_by_order_by_count
    description: |
      Aggregation: Gruppieren nach `name` und zählen der Zeilen pro Name.
      Ergebnis soll absteigend nach Anzahl sortiert sein.
    sql: "SELECT name, COUNT(*) AS rows FROM test_table GROUP BY name ORDER BY COUNT(*) DESC"
    expected:
      cols: [name, rows]
      rows:
        - {name: "alice", rows: 3}
        - {name: "bob", rows: 1}
        - {name: "charlie", rows: 1}

  - id: subselect_from_group_by
    description: |
      Abgeleitete Tabelle (Subselect im FROM):
      Die innere Abfrage gruppiert nach `name` und liefert `rows` (Zähler).
      Die äußere Abfrage sortiert das Ergebnis nach `rows` absteigend.
    sql: |
      SELECT * FROM (
        SELECT name, COUNT(*) AS rows FROM test_table GROUP BY name
      ) x ORDER BY rows DESC
    expected:
      cols: [name, rows]
      rows:
        - {name: "alice", rows: 3}
        - {name: "bob", rows: 1}
        - {name: "charlie", rows: 1}

  - id: join_and_aggregate
    description: |
      JOIN-Beispiel: Nutzer + Bestellungen. Zeige Namen mit SUM und COUNT
      nur für bestellte (PAID) Bestellungen, gruppiert nach Nutzer.
    sql: |
      SELECT u.name, COUNT(o.id) AS order_count, SUM(o.amount) AS total
      FROM users u
      JOIN orders o ON u.id = o.user_id
      WHERE o.status = 'PAID'
      GROUP BY u.id, u.name
      ORDER BY total DESC
    expected:
      cols: [name, order_count, total]
      rows:
        - {name: "alice", order_count: 2, total: 400.0}
        - {name: "bob", order_count: 1, total: 150.0}

# Hinweis zur Benutzung:
# - Diese YAML-Datei ist bewusst einfach gehalten: Tabellen, Queries, erwartete Spalten und
#   eine Liste von Zeilen (als Mapping) für die Überprüfung.
# - Tests können die Tabellen aus `tables` erzeugen (CREATE TABLE + INSERTs),
#   dann die `sql`-Abfragen ausführen und das ResultSet gegen `expected` vergleichen.
# - Für numerische Vergleiche ist auf Typkompatibilität zu achten (int vs. int64 vs. float).
# - Für Erweiterungen: zusätzliche Metadaten (z.B. erwartete Fehler, optionaler Skip) können hinzugefügt werden.
